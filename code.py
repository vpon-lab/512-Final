import time
import board
import busio
import displayio
import adafruit_displayio_ssd1306
import terminalio
from adafruit_display_text import label
import i2cdisplaybus
from rotary_encoder import RotaryEncoder
from digitalio import DigitalInOut, Direction, Pull
import random
import adafruit_adxl34x
import math
import neopixel

displayio.release_displays()

## Code generated by ChatGPT

# -----------------------------------------
# ROTARY ENCODER
# -----------------------------------------
encoder = RotaryEncoder(board.D8, board.D7, debounce_ms=3, pulses_per_detent=3)

btn = DigitalInOut(board.D9)
btn.direction = Direction.INPUT
btn.pull = Pull.UP
prev_state = btn.value

# -----------------------------------------
# OLED setup
# -----------------------------------------
i2c = busio.I2C(board.SCL, board.SDA)
display_bus = i2cdisplaybus.I2CDisplayBus(i2c, device_address=0x3C)
display = adafruit_displayio_ssd1306.SSD1306(display_bus, width=128, height=64)

# Screen group
splash = displayio.Group()
display.root_group = splash

text_layer = label.Label(terminalio.FONT, text="")
splash.append(text_layer)

# -----------------------------------------
# Accelerometer setup
# -----------------------------------------
accelerometer = adafruit_adxl34x.ADXL345(i2c)

start_time = time.monotonic()
response_time = None
prev_encoder_pos = encoder.position

alpha = 0.2

FORWARD_ANGLE = 35
BACKWARD_ANGLE = -35
EXIT_ANGLE = 5
state = "neutral"
neutral_start = None
twist_cooldown = 0.3
last_success_time = 0

pixel_pin = board.D10
num_pixels = 1
pixels = neopixel.NeoPixel(pixel_pin, num_pixels, brightness=0.3, auto_write=True)

RED = (255, 0, 0)
YELLOW = (255, 150, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)

# -----------------------------------------
# DIFFICULTY MENU 
# -----------------------------------------

options = ["Easy", "Medium", "Hard"]
index = 0

def center_txt(layer):
    layer.x = (display.width - text_layer.bounding_box[2]) // 2
    layer.y = (display.height - text_layer.bounding_box[3]) // 2

def draw_menu():
    text = ""
    for i, opt in enumerate(options):
        if i == index:
            text += "> " + opt + "\n"
        else:
            text += "  " + opt + "\n"

    text_layer.text = text
    center_txt(text_layer)

def select_difficulty():
    global index, prev_state

    # Show first message
    text_layer.text = "Select Mode"
    center_txt(text_layer)
    time.sleep(1)

    draw_menu()

    # Track encoder movement
    prev_pos = encoder.position

    while True:
        encoder.update()
        cur_pos = encoder.position

        # ROTATION movement
        delta = cur_pos - prev_pos

        if delta != 0:
            # Clamp movement to +1 or -1
            step = 1 if delta > 0 else -1
            index = (index + step) % len(options)
            draw_menu()
            prev_pos = cur_pos
            time.sleep(0.15)

        # BUTTON PRESS
        cur = btn.value
        if prev_state and not cur:  # falling edge
            chosen = options[index]
            text_layer.text = "Chosen: " + chosen
            center_txt(text_layer)
            time.sleep(1)
            return chosen

        prev_state = cur

# Timer values by difficulty
def diff_mode(choice):
    if choice == "Easy":
        return 20
    if choice == "Medium":
        return 10
    if choice == "Hard":
        return 5

# --------------------------------------------------
# GET DIFFICULTY SELECTION NOW
# --------------------------------------------------
difficulty_choice = select_difficulty()
timer_limit = diff_mode(difficulty_choice)

# --------------------------------------------------
# Diplaying the 10 levels
# --------------------------------------------------
current_level = 1 

def display_level():
    text_layer.text = f"Level {current_level}"
    center_txt(text_layer)
    
    if current_level > 10:
        text_layer.text = "YOU WIN!"
        center_text(text_layer)

def beat_level(current_level):
    current_level += 1
    display_level()
  

# --------------------------------------------------
# Transitioning between levels 
# --------------------------------------------------
# Available moves
def twistIt():
    text_layer.text = "Twist it!"
    center_txt(text_layer)

def pushIt():
    text_layer.text = "Push it!"
    center_txt(text_layer)

def forward():
    text_layer.text = "Forward!"
    center_txt(text_layer)

def backward():
    text_layer.text = "Backward!"
    center_txt(text_layer)
    
    
plays = [
    {"label": "Twist it!", "func": twistIt, "check": lambda p: p == "Twist it!"},
    {"label": "Push it!",  "func": pushIt,  "check": lambda p: p == "Push it!"},
    {"label": "Forward!", "func": forward, "check": lambda p: p == "Forward!"},
    {"label": "Backward!","func": backward,"check": lambda p: p == "Backward!"},
]

# Define levels: each level is a list of possible moves and number of rounds
levels_config = [
    {"moves": ["Push it!"], "rounds": 3},                  # Level 1
    {"moves": ["Twist it!"], "rounds": 3},                # Level 2
    {"moves": ["Forward!"], "rounds": 3},                 # Level 3
    {"moves": ["Backward!"], "rounds": 3},                # Level 4
    {"moves": ["Push it!", "Twist it!"], "rounds": 4},    # Level 5
    {"moves": ["Forward!", "Backward!"], "rounds": 4},    # Level 6
    {"moves": ["Push it!", "Twist it!", "Forward!"], "rounds": 5},  # Level 7
    {"moves": ["Push it!", "Twist it!", "Forward!", "Backward!"], "rounds": 5},  # Level 8
    {"moves": ["Push it!", "Twist it!", "Forward!", "Backward!"], "rounds": 7},  # Level 9
    {"moves": ["Push it!", "Twist it!", "Forward!", "Backward!"], "rounds": 8},  # Level 10
]

def get_move_obj(label_name):
    for move in plays:
        if move["label"] == label_name:
            return move
    return None

def display_level(level):
    text_layer.text = f"Level {level}"
    center_txt(text_layer)
    time.sleep(0.7)
    
def play_level(level_number):
    # Before the rounds loop:
    global state
    ax, ay, az = accelerometer.acceleration
    pitch_filtered = get_pitch(ax - x_b, ay - y_b, az)  # initialize filter correctly

    config = levels_config[level_number - 1]
    rounds = config["rounds"]
    level_moves = config["moves"]

    for r in range(rounds):
        label_name = random.choice(level_moves)
        move_obj = get_move_obj(label_name)
        move_obj["func"]()
        expected = move_obj["label"]
        
        state = "neutral" 

        start_time = time.monotonic()
        while True:
            ax, ay, az = accelerometer.acceleration
            pitch_raw = get_pitch(ax - x_b, ay - y_b, az)
            pitch_filtered = alpha * pitch_raw + (1 - alpha) * pitch_filtered

            move = player_response(pitch_filtered)  # pass it in
            # Ignore noise or moves not allowed in this difficulty
            if move and move not in current_allowed:
                move = None

            if move == expected:
                set_color(GREEN)
                text_layer.text = "Nice!"
                center_txt(text_layer)
                time.sleep(0.7)
                state = "neutral"
                break
            
            elif move:
                set_color(RED)
                text_layer.text = "Wrong move!"
                center_txt(text_layer)
                time.sleep(1)
                text_layer.text = "Game Over!"
                center_txt(text_layer)
                set_color((255, 255, 255))
                return False
            
            elif time.monotonic() - start_time > timer_limit:
                set_color(RED)
                text_layer.text = "Times Up!"
                center_txt(text_layer)
                time.sleep(1)
                text_layer.text = "Game Over!"
                center_txt(text_layer)
                set_color((255, 255, 255))
                return False
            time.sleep(0.001)
    return True

allowed_moves = {
    "Easy": ["Push it!", "Twist it!", "Forward!", "Backward!"],
    "Medium": ["Push it!", "Twist it!", "Forward!", "Backward!"],
    "Hard": ["Push it!", "Twist it!", "Forward!", "Backward!"]
}

current_allowed = allowed_moves[difficulty_choice]

def player_response(pitch_filtered):
    push, twist = update_inputs()
    tilt_fwd = detect_forwardTilt(pitch_filtered)
    tilt_back = detect_backwardTilt(pitch_filtered)

    if push:
        return "Push it!"

    if twist:
        return "Twist it!"

    if tilt_fwd:
        return "Forward!"

    if tilt_back:
        return "Backward!"

    return None

def play_again_menu():
    global prev_state, prev_encoder_pos 
    options = ["Yes", "No"]
    index = 0

    text_layer.text = "Play Again?"
    center_txt(text_layer)
    time.sleep(0.5)

    while True:
        encoder.update()
        cur_pos = encoder.position

        delta = cur_pos - prev_encoder_pos
        if delta != 0:
            step = 1 if delta > 0 else -1
            index = (index + step) % len(options)
            # Display menu
            text = ""
            for i, opt in enumerate(options):
                if i == index:
                    text += "> " + opt + "\n"
                else:
                    text += "  " + opt + "\n"
            text_layer.text = text
            center_txt(text_layer)
            prev_encoder_pos = cur_pos
            time.sleep(0.15)

        # Button press
        cur = btn.value
        global prev_state
        if prev_state and not cur:  # falling edge
            return options[index] == "Yes"
        prev_state = cur


def set_color(color):
    pixels.fill(color)
    pixels.brightness = 0.03
    pixels.show()

def calibrate_zero(accel, samples=50, delay=0.01):
    x_list, y_list = [], []
    for _ in range(samples):
        x, y, _ = accel.acceleration
        x_list.append(x)
        y_list.append(y)
        time.sleep(delay)
    return sum(x_list) / samples, sum(y_list) / samples

def get_pitch(ax, ay, az):
    return math.degrees(math.atan2(ay, math.sqrt(ax*ax + az*az)))

def detect_neutral(pitch):
    global state, neutral_start
    if -EXIT_ANGLE < pitch < EXIT_ANGLE:
        if state != "neutral":
            state = "neutral"
            neutral_start = time.monotonic()
            return True
    return False

def detect_forwardTilt(pitch):
    global state
    if pitch > FORWARD_ANGLE and state != "forward":
        state = "forward"
        return True
    detect_neutral(pitch)
    return False

def detect_backwardTilt(pitch):
    global state
    if pitch < BACKWARD_ANGLE and state != "backward":
        state = "backward"
        return True
    detect_neutral(pitch)
    return False

def update_inputs():
    global prev_encoder_pos, prev_state

    encoder.update()
    delta = encoder.position - prev_encoder_pos
    twist = False
    if abs(delta) >= 3:
        prev_encoder_pos = encoder.position
        twist = True

    cur = btn.value
    push = False
    if prev_state and not cur:
        push = True
    prev_state = cur

    return push, twist

game_over = False
x_b, y_b = calibrate_zero(accelerometer)

# -----------------------------------------
# Main game loop
# -----------------------------------------

while True:
    # Reset game state
    current_level = 1
    game_over = False
    prev_encoder_pos = encoder.position
    current_allowed = allowed_moves[difficulty_choice]

    while current_level <= 10 and not game_over:
        display_level(current_level)
        success = play_level(current_level)
        if success:
            current_level += 1
        else:
            game_over = True

    if current_level > 10:
        text_layer.text = "YOU WIN!"
        center_txt(text_layer)

    # Ask to play again
    if play_again_menu():
        # Optional: select new difficulty
        difficulty_choice = select_difficulty()
        timer_limit = diff_mode(difficulty_choice)
        current_allowed = allowed_moves[difficulty_choice]
    else:
        text_layer.text = "Thanks for playing!"
        center_txt(text_layer)
        break


